# 后端用户角色修复指南

根据前端代码分析和您提供的 `User` 实体类信息，我们发现当前权限问题可能是由于后端返回的用户信息中角色字段不正确或未正确传递到前端导致的。以下是修复步骤：

## 1. 检查 UserController 中的登录接口

确保登录接口返回的用户信息中包含正确的角色字段：

```java
package com.gxwz.syschronicdisease.controller;

import com.gxwz.syschronicdisease.entity.Result;
import com.gxwz.syschronicdisease.entity.User;
import com.gxwz.syschronicdisease.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/user")
@CrossOrigin
public class UserController {

    @Autowired
    private UserService userService;

    @PostMapping("/login")
    public Result login(@RequestBody User loginUser) {
        User user = userService.login(loginUser.getUserid(), loginUser.getPassword());
        
        if (user != null) {
            // 创建返回数据
            Map<String, Object> data = new HashMap<>();
            
            // 确保包含角色信息
            data.put("userid", user.getUserid());
            data.put("fullname", user.getFullname());
            data.put("role", user.getRole()); // 重要：确保角色字段被包含
            
            // 生成token（如果有的话）
            String token = generateToken(user);
            data.put("token", token);
            
            return new Result("登录成功", data, 200);
        } else {
            return new Result("用户名或密码错误", null, 401);
        }
    }
    
    // 其他方法...
    
    private String generateToken(User user) {
        // 生成token的逻辑
        return "token_" + System.currentTimeMillis() + "_" + user.getUserid();
    }
}
```

## 2. 确保数据库中有超级管理员角色

检查数据库中的用户表，确保有超级管理员角色的用户：

```sql
-- 查询当前用户角色
SELECT userid, fullname, role FROM user;

-- 如果需要，更新用户为超级管理员
UPDATE user SET role = 'superadmin' WHERE userid = 'admin';

-- 或者创建一个新的超级管理员用户
INSERT INTO user (userid, password, fullname, role) 
VALUES ('superadmin', '加密后的密码', '超级管理员', 'superadmin');
```

## 3. 检查 UserService 实现

确保 `UserService` 的实现正确获取用户信息，包括角色：

```java
package com.gxwz.syschronicdisease.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.gxwz.syschronicdisease.entity.User;
import com.gxwz.syschronicdisease.mapper.UserMapper;
import com.gxwz.syschronicdisease.service.UserService;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {

    @Override
    public User login(String userid, String password) {
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userid", userid);
        queryWrapper.eq("password", password);
        
        // 返回完整的用户信息，包括角色
        return this.getOne(queryWrapper);
    }
    
    // 其他方法...
}
```

## 4. 检查 User 实体类映射

确保 `User` 实体类与数据库表的映射正确：

```java
package com.gxwz.syschronicdisease.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@TableName("user")
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {

    @TableId(type = IdType.AUTO)
    private Integer id;
    private String userid;
    private String password;
    private String fullname;
    private String role;  // 确保这个字段与数据库表中的字段名匹配
}
```

## 5. 调试步骤

1. 使用数据库工具查看 `user` 表，确认有超级管理员角色的用户
2. 在 `UserController` 的 `login` 方法中添加日志，打印返回的用户信息
3. 使用超级管理员账号登录，检查后端日志中打印的用户信息是否包含正确的角色
4. 使用浏览器开发者工具查看登录响应，确认返回的数据中包含角色信息

## 临时解决方案

如果后端修改需要时间，可以在前端临时添加以下代码来解决问题：

1. 登录后手动设置角色：
```javascript
// 在登录成功后
const userInfo = JSON.parse(localStorage.getItem('user') || '{}')
userInfo.role = 'superadmin'  // 设置为超级管理员
localStorage.setItem('user', JSON.stringify(userInfo))
```

2. 或者使用我们已经添加的"刷新权限"按钮临时获取权限

## 总结

问题的核心是确保：
1. 数据库中有超级管理员角色的用户
2. 后端正确返回用户的角色信息
3. 前端正确解析和使用这个角色信息

通过以上修改，应该能够解决超级管理员无法进行权限设置的问题。 